import{g as k}from"./popup.js";import{V as U}from"./popup-index2.js";import"./popup-index3.js";function j(t){if(t)throw t}var x,C;function B(){if(C)return x;C=1;var t=Object.prototype.hasOwnProperty,e=Object.prototype.toString,n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,r=function(s){return typeof Array.isArray=="function"?Array.isArray(s):e.call(s)==="[object Array]"},o=function(s){if(!s||e.call(s)!=="[object Object]")return!1;var c=t.call(s,"constructor"),l=s.constructor&&s.constructor.prototype&&t.call(s.constructor.prototype,"isPrototypeOf");if(s.constructor&&!c&&!l)return!1;var h;for(h in s);return typeof h>"u"||t.call(s,h)},f=function(s,c){n&&c.name==="__proto__"?n(s,c.name,{enumerable:!0,configurable:!0,value:c.newValue,writable:!0}):s[c.name]=c.newValue},a=function(s,c){if(c==="__proto__")if(t.call(s,c)){if(i)return i(s,c).value}else return;return s[c]};return x=function u(){var s,c,l,h,p,m,d=arguments[0],w=1,N=arguments.length,P=!1;for(typeof d=="boolean"&&(P=d,d=arguments[1]||{},w=2),(d==null||typeof d!="object"&&typeof d!="function")&&(d={});w<N;++w)if(s=arguments[w],s!=null)for(c in s)l=a(d,c),h=a(s,c),d!==h&&(P&&h&&(o(h)||(p=r(h)))?(p?(p=!1,m=l&&r(l)?l:[]):m=l&&o(l)?l:{},f(d,{name:c,newValue:u(P,m,h)})):typeof h<"u"&&f(d,{name:c,newValue:h}));return d},x}var q=B();const E=k(q);function _(t){if(typeof t!="object"||t===null)return!1;const e=Object.getPrototypeOf(t);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in t)&&!(Symbol.iterator in t)}function H(){const t=[],e={run:n,use:i};return e;function n(...r){let o=-1;const f=r.pop();if(typeof f!="function")throw new TypeError("Expected function as last argument, not "+f);a(null,...r);function a(u,...s){const c=t[++o];let l=-1;if(u){f(u);return}for(;++l<r.length;)(s[l]===null||s[l]===void 0)&&(s[l]=r[l]);r=s,c?$(c,a)(...s):f(null,...s)}}function i(r){if(typeof r!="function")throw new TypeError("Expected `middelware` to be a function, not "+r);return t.push(r),e}}function $(t,e){let n;return i;function i(...f){const a=t.length>f.length;let u;a&&f.push(r);try{u=t.apply(this,f)}catch(s){const c=s;if(a&&n)throw c;return r(c)}a||(u&&u.then&&typeof u.then=="function"?u.then(o,r):u instanceof Error?r(u):o(u))}function r(f,...a){n||(n=!0,e(f,...a))}function o(f){r(null,f)}}const y={basename:M,dirname:Y,extname:G,join:J,sep:"/"};function M(t,e){if(e!==void 0&&typeof e!="string")throw new TypeError('"ext" argument must be a string');g(t);let n=0,i=-1,r=t.length,o;if(e===void 0||e.length===0||e.length>t.length){for(;r--;)if(t.codePointAt(r)===47){if(o){n=r+1;break}}else i<0&&(o=!0,i=r+1);return i<0?"":t.slice(n,i)}if(e===t)return"";let f=-1,a=e.length-1;for(;r--;)if(t.codePointAt(r)===47){if(o){n=r+1;break}}else f<0&&(o=!0,f=r+1),a>-1&&(t.codePointAt(r)===e.codePointAt(a--)?a<0&&(i=r):(a=-1,i=f));return n===i?i=f:i<0&&(i=t.length),t.slice(n,i)}function Y(t){if(g(t),t.length===0)return".";let e=-1,n=t.length,i;for(;--n;)if(t.codePointAt(n)===47){if(i){e=n;break}}else i||(i=!0);return e<0?t.codePointAt(0)===47?"/":".":e===1&&t.codePointAt(0)===47?"//":t.slice(0,e)}function G(t){g(t);let e=t.length,n=-1,i=0,r=-1,o=0,f;for(;e--;){const a=t.codePointAt(e);if(a===47){if(f){i=e+1;break}continue}n<0&&(f=!0,n=e+1),a===46?r<0?r=e:o!==1&&(o=1):r>-1&&(o=-1)}return r<0||n<0||o===0||o===1&&r===n-1&&r===i+1?"":t.slice(r,n)}function J(...t){let e=-1,n;for(;++e<t.length;)g(t[e]),t[e]&&(n=n===void 0?t[e]:n+"/"+t[e]);return n===void 0?".":K(n)}function K(t){g(t);const e=t.codePointAt(0)===47;let n=Q(t,!e);return n.length===0&&!e&&(n="."),n.length>0&&t.codePointAt(t.length-1)===47&&(n+="/"),e?"/"+n:n}function Q(t,e){let n="",i=0,r=-1,o=0,f=-1,a,u;for(;++f<=t.length;){if(f<t.length)a=t.codePointAt(f);else{if(a===47)break;a=47}if(a===47){if(!(r===f-1||o===1))if(r!==f-1&&o===2){if(n.length<2||i!==2||n.codePointAt(n.length-1)!==46||n.codePointAt(n.length-2)!==46){if(n.length>2){if(u=n.lastIndexOf("/"),u!==n.length-1){u<0?(n="",i=0):(n=n.slice(0,u),i=n.length-1-n.lastIndexOf("/")),r=f,o=0;continue}}else if(n.length>0){n="",i=0,r=f,o=0;continue}}e&&(n=n.length>0?n+"/..":"..",i=2)}else n.length>0?n+="/"+t.slice(r+1,f):n=t.slice(r+1,f),i=f-r-1;r=f,o=0}else a===46&&o>-1?o++:o=-1}return n}function g(t){if(typeof t!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}const W={cwd:X};function X(){return"/"}function z(t){return!!(t!==null&&typeof t=="object"&&"href"in t&&t.href&&"protocol"in t&&t.protocol&&t.auth===void 0)}function Z(t){if(typeof t=="string")t=new URL(t);else if(!z(t)){const e=new TypeError('The "path" argument must be of type string or an instance of URL. Received `'+t+"`");throw e.code="ERR_INVALID_ARG_TYPE",e}if(t.protocol!=="file:"){const e=new TypeError("The URL must be of scheme file");throw e.code="ERR_INVALID_URL_SCHEME",e}return v(t)}function v(t){if(t.hostname!==""){const i=new TypeError('File URL host must be "localhost" or empty on darwin');throw i.code="ERR_INVALID_FILE_URL_HOST",i}const e=t.pathname;let n=-1;for(;++n<e.length;)if(e.codePointAt(n)===37&&e.codePointAt(n+1)===50){const i=e.codePointAt(n+2);if(i===70||i===102){const r=new TypeError("File URL path must not include encoded / characters");throw r.code="ERR_INVALID_FILE_URL_PATH",r}}return decodeURIComponent(e)}const A=["history","path","basename","stem","extname","dirname"];class ee{constructor(e){let n;e?z(e)?n={path:e}:typeof e=="string"||te(e)?n={value:e}:n=e:n={},this.cwd="cwd"in n?"":W.cwd(),this.data={},this.history=[],this.messages=[],this.value,this.map,this.result,this.stored;let i=-1;for(;++i<A.length;){const o=A[i];o in n&&n[o]!==void 0&&n[o]!==null&&(this[o]=o==="history"?[...n[o]]:n[o])}let r;for(r in n)A.includes(r)||(this[r]=n[r])}get basename(){return typeof this.path=="string"?y.basename(this.path):void 0}set basename(e){S(e,"basename"),I(e,"basename"),this.path=y.join(this.dirname||"",e)}get dirname(){return typeof this.path=="string"?y.dirname(this.path):void 0}set dirname(e){D(this.basename,"dirname"),this.path=y.join(e||"",this.basename)}get extname(){return typeof this.path=="string"?y.extname(this.path):void 0}set extname(e){if(I(e,"extname"),D(this.dirname,"extname"),e){if(e.codePointAt(0)!==46)throw new Error("`extname` must start with `.`");if(e.includes(".",1))throw new Error("`extname` cannot contain multiple dots")}this.path=y.join(this.dirname,this.stem+(e||""))}get path(){return this.history[this.history.length-1]}set path(e){z(e)&&(e=Z(e)),S(e,"path"),this.path!==e&&this.history.push(e)}get stem(){return typeof this.path=="string"?y.basename(this.path,this.extname):void 0}set stem(e){S(e,"stem"),I(e,"stem"),this.path=y.join(this.dirname||"",e+(this.extname||""))}fail(e,n,i){const r=this.message(e,n,i);throw r.fatal=!0,r}info(e,n,i){const r=this.message(e,n,i);return r.fatal=void 0,r}message(e,n,i){const r=new U(e,n,i);return this.path&&(r.name=this.path+":"+r.name,r.file=this.path),r.fatal=!1,this.messages.push(r),r}toString(e){return this.value===void 0?"":typeof this.value=="string"?this.value:new TextDecoder(e||void 0).decode(this.value)}}function I(t,e){if(t&&t.includes(y.sep))throw new Error("`"+e+"` cannot be a path: did not expect `"+y.sep+"`")}function S(t,e){if(!t)throw new Error("`"+e+"` cannot be empty")}function D(t,e){if(!t)throw new Error("Setting `"+e+"` requires `path` to be set too")}function te(t){return!!(t&&typeof t=="object"&&"byteLength"in t&&"byteOffset"in t)}const ne=function(t){const i=this.constructor.prototype,r=i[t],o=function(){return r.apply(o,arguments)};return Object.setPrototypeOf(o,i),o},re={}.hasOwnProperty;class L extends ne{constructor(){super("copy"),this.Compiler=void 0,this.Parser=void 0,this.attachers=[],this.compiler=void 0,this.freezeIndex=-1,this.frozen=void 0,this.namespace={},this.parser=void 0,this.transformers=H()}copy(){const e=new L;let n=-1;for(;++n<this.attachers.length;){const i=this.attachers[n];e.use(...i)}return e.data(E(!0,{},this.namespace)),e}data(e,n){return typeof e=="string"?arguments.length===2?(R("data",this.frozen),this.namespace[e]=n,this):re.call(this.namespace,e)&&this.namespace[e]||void 0:e?(R("data",this.frozen),this.namespace=e,this):this.namespace}freeze(){if(this.frozen)return this;const e=this;for(;++this.freezeIndex<this.attachers.length;){const[n,...i]=this.attachers[this.freezeIndex];if(i[0]===!1)continue;i[0]===!0&&(i[0]=void 0);const r=n.call(e,...i);typeof r=="function"&&this.transformers.use(r)}return this.frozen=!0,this.freezeIndex=Number.POSITIVE_INFINITY,this}parse(e){this.freeze();const n=b(e),i=this.parser||this.Parser;return T("parse",i),i(String(n),n)}process(e,n){const i=this;return this.freeze(),T("process",this.parser||this.Parser),O("process",this.compiler||this.Compiler),n?r(void 0,n):new Promise(r);function r(o,f){const a=b(e),u=i.parse(a);i.run(u,a,function(c,l,h){if(c||!l||!h)return s(c);const p=l,m=i.stringify(p,h);se(m)?h.value=m:h.result=m,s(c,h)});function s(c,l){c||!l?f(c):o?o(l):n(void 0,l)}}}processSync(e){let n=!1,i;return this.freeze(),T("processSync",this.parser||this.Parser),O("processSync",this.compiler||this.Compiler),this.process(e,r),V("processSync","process",n),i;function r(o,f){n=!0,j(o),i=f}}run(e,n,i){F(e),this.freeze();const r=this.transformers;return!i&&typeof n=="function"&&(i=n,n=void 0),i?o(void 0,i):new Promise(o);function o(f,a){const u=b(n);r.run(e,u,s);function s(c,l,h){const p=l||e;c?a(c):f?f(p):i(void 0,p,h)}}}runSync(e,n){let i=!1,r;return this.run(e,n,o),V("runSync","run",i),r;function o(f,a){j(f),r=a,i=!0}}stringify(e,n){this.freeze();const i=b(n),r=this.compiler||this.Compiler;return O("stringify",r),F(e),r(e,i)}use(e,...n){const i=this.attachers,r=this.namespace;if(R("use",this.frozen),e!=null)if(typeof e=="function")u(e,n);else if(typeof e=="object")Array.isArray(e)?a(e):f(e);else throw new TypeError("Expected usable value, not `"+e+"`");return this;function o(s){if(typeof s=="function")u(s,[]);else if(typeof s=="object")if(Array.isArray(s)){const[c,...l]=s;u(c,l)}else f(s);else throw new TypeError("Expected usable value, not `"+s+"`")}function f(s){if(!("plugins"in s)&&!("settings"in s))throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");a(s.plugins),s.settings&&(r.settings=E(!0,r.settings,s.settings))}function a(s){let c=-1;if(s!=null)if(Array.isArray(s))for(;++c<s.length;){const l=s[c];o(l)}else throw new TypeError("Expected a list of plugins, not `"+s+"`")}function u(s,c){let l=-1,h=-1;for(;++l<i.length;)if(i[l][0]===s){h=l;break}if(h===-1)i.push([s,...c]);else if(c.length>0){let[p,...m]=c;const d=i[h][1];_(d)&&_(p)&&(p=E(!0,d,p)),i[h]=[s,p,...m]}}}}const le=new L().freeze();function T(t,e){if(typeof e!="function")throw new TypeError("Cannot `"+t+"` without `parser`")}function O(t,e){if(typeof e!="function")throw new TypeError("Cannot `"+t+"` without `compiler`")}function R(t,e){if(e)throw new Error("Cannot call `"+t+"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")}function F(t){if(!_(t)||typeof t.type!="string")throw new TypeError("Expected node, got `"+t+"`")}function V(t,e,n){if(!n)throw new Error("`"+t+"` finished async. Use `"+e+"` instead")}function b(t){return ie(t)?t:new ee(t)}function ie(t){return!!(t&&typeof t=="object"&&"message"in t&&"messages"in t)}function se(t){return typeof t=="string"||oe(t)}function oe(t){return!!(t&&typeof t=="object"&&"byteLength"in t&&"byteOffset"in t)}export{le as unified};
